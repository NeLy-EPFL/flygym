<!doctype html>
<html class="no-js" lang="en" data-content_root="../">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DF8S7T56G7"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-DF8S7T56G7');
    </script>
    <link rel="index" title="Index" href="../genindex.html" /><link rel="search" title="Search" href="../search.html" /><link rel="next" title="API Reference" href="../api_ref/index.html" /><link rel="prev" title="Connectome-constrained visual system model" href="advanced_vision.html" />
        <link rel="prefetch" href="https://github.com/NeLy-EPFL/_media/blob/main/flygym/banner_small.jpg?raw=true" as="image" />

    <link rel="shortcut icon" href="../_static/favicon.ico"/><!-- Generated with Sphinx 8.2.3 and Furo 2025.07.19 -->
        <title>Advanced olfaction: Navigating a complex odor plume - NeuroMechFly documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=d111a655" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo.css?v=25af2a20" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/furo-extensions.css?v=8dab3a3b" />
    
    


<style>
  body {
    --color-code-background: #f2f2f2;
  --color-code-foreground: #1e1e1e;
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #2b2b2b;
  --color-code-foreground: #f8f8f2;
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #2b2b2b;
  --color-code-foreground: #f8f8f2;
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-with-moon" viewBox="0 0 24 24">
    <title>Auto light/dark, in light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path style="opacity: 50%" d="M 5.411 14.504 C 5.471 14.504 5.532 14.504 5.591 14.504 C 3.639 16.319 4.383 19.569 6.931 20.352 C 7.693 20.586 8.512 20.551 9.25 20.252 C 8.023 23.207 4.056 23.725 2.11 21.184 C 0.166 18.642 1.702 14.949 4.874 14.536 C 5.051 14.512 5.231 14.5 5.411 14.5 L 5.411 14.504 Z"/>
      <line x1="14.5" y1="3.25" x2="14.5" y2="1.25"/>
      <line x1="14.5" y1="15.85" x2="14.5" y2="17.85"/>
      <line x1="10.044" y1="5.094" x2="8.63" y2="3.68"/>
      <line x1="19" y1="14.05" x2="20.414" y2="15.464"/>
      <line x1="8.2" y1="9.55" x2="6.2" y2="9.55"/>
      <line x1="20.8" y1="9.55" x2="22.8" y2="9.55"/>
      <line x1="10.044" y1="14.006" x2="8.63" y2="15.42"/>
      <line x1="19" y1="5.05" x2="20.414" y2="3.636"/>
      <circle cx="14.5" cy="9.55" r="3.6"/>
    </svg>
  </symbol>
  <symbol id="svg-moon-with-sun" viewBox="0 0 24 24">
    <title>Auto light/dark, in dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round"
      class="icon-custom-derived-from-feather-sun-and-tabler-moon">
      <path d="M 8.282 7.007 C 8.385 7.007 8.494 7.007 8.595 7.007 C 5.18 10.184 6.481 15.869 10.942 17.24 C 12.275 17.648 13.706 17.589 15 17.066 C 12.851 22.236 5.91 23.143 2.505 18.696 C -0.897 14.249 1.791 7.786 7.342 7.063 C 7.652 7.021 7.965 7 8.282 7 L 8.282 7.007 Z"/>
      <line style="opacity: 50%" x1="18" y1="3.705" x2="18" y2="2.5"/>
      <line style="opacity: 50%" x1="18" y1="11.295" x2="18" y2="12.5"/>
      <line style="opacity: 50%" x1="15.316" y1="4.816" x2="14.464" y2="3.964"/>
      <line style="opacity: 50%" x1="20.711" y1="10.212" x2="21.563" y2="11.063"/>
      <line style="opacity: 50%" x1="14.205" y1="7.5" x2="13.001" y2="7.5"/>
      <line style="opacity: 50%" x1="21.795" y1="7.5" x2="23" y2="7.5"/>
      <line style="opacity: 50%" x1="15.316" y1="10.184" x2="14.464" y2="11.036"/>
      <line style="opacity: 50%" x1="20.711" y1="4.789" x2="21.563" y2="3.937"/>
      <circle style="opacity: 50%" cx="18" cy="7.5" r="2.169"/>
    </svg>
  </symbol>
  <symbol id="svg-pencil" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-pencil-code">
      <path d="M4 20h4l10.5 -10.5a2.828 2.828 0 1 0 -4 -4l-10.5 10.5v4" />
      <path d="M13.5 6.5l4 4" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
  <symbol id="svg-eye" viewBox="0 0 24 24">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-eye-code">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" />
      <path
        d="M11.11 17.958c-3.209 -.307 -5.91 -2.293 -8.11 -5.958c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6c-.21 .352 -.427 .688 -.647 1.008" />
      <path d="M20 21l2 -2l-2 -2" />
      <path d="M17 17l-2 2l2 2" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>

<a class="skip-to-content muted-link" href="#furo-main-content">Skip to content</a>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="../index.html"><div class="brand">NeuroMechFly documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
          <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="../index.html">
  <div class="sidebar-logo-container">
    <img class="sidebar-logo" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/banner_small.jpg?raw=true" alt="Logo"/>
  </div>
  
  <span class="sidebar-brand-text">NeuroMechFly documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="../search.html" role="search">
  <input class="sidebar-search" placeholder="Search" name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../neuromechfly.html">The NeuroMechFly Model</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../gallery/index.html">Gallery</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" role="switch" type="checkbox"/><label for="toctree-checkbox-1"><div class="visually-hidden">Toggle navigation of Gallery</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_3_forces.html">Estimating contact forces</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_4_climbing.html">Climbing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_8_controller_comparison.html">Controller comparison</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_9_visual_taxis.html">Visual taxis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_10_odour_taxis.html">Odour Taxis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_11_head_stabilization.html">Head stabilization on complex terrain</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_12_multimodal_navigation.html">Multimodal navigation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_13_plume_navigation.html">Plume navigation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../gallery/video_14_fly_follow_fly.html">Fly chasing with a connectome constrained visual system</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1 current has-children"><a class="reference internal" href="index.html">Tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" role="switch" type="checkbox"/><label for="toctree-checkbox-2"><div class="visually-hidden">Toggle navigation of Tutorials</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gym_basics_and_kinematic_replay.html">Interacting with NeuroMechFly</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpg_controller.html">Controlling locomotion with CPGs</a></li>
<li class="toctree-l2"><a class="reference internal" href="rule_based_controller.html">Rule-based controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="hybrid_controller.html">Overcome complex terrain with a hybrid controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="turning.html">Encapsulating custom code into Gym environments: A turning controller</a></li>
<li class="toctree-l2"><a class="reference internal" href="vision_basics.html">Vision basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="olfaction_basics.html">Olfaction basics</a></li>
<li class="toctree-l2"><a class="reference internal" href="path_integration.html">Path integration</a></li>
<li class="toctree-l2"><a class="reference internal" href="head_stabilization.html">Head stabilization</a></li>
<li class="toctree-l2"><a class="reference internal" href="advanced_vision.html">Connectome-constrained visual system model</a></li>
<li class="toctree-l2 current current-page"><a class="current reference internal" href="#">Advanced olfaction: Navigating a complex odor plume</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../api_ref/index.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" role="switch" type="checkbox"/><label for="toctree-checkbox-3"><div class="visually-hidden">Toggle navigation of API Reference</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/mdp_specs.html">MDP Task Specifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/fly.html">Fly</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/arena.html">Arena</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/camera.html">Camera</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/simulation.html">Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/state.html">State</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/vision.html">Vision</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/olfaction.html">Olfaction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/utils.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/preprogrammed.html">Preprogrammed</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../api_ref/examples/index.html">FlyGym Examples</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" role="switch" type="checkbox"/><label for="toctree-checkbox-4"><div class="visually-hidden">Toggle navigation of FlyGym Examples</div><i class="icon"><svg><use href="#svg-arrow-right"></use></svg></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="../api_ref/examples/locomotion.html">Locomotion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_ref/examples/vision.html">Advanced Vision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_ref/examples/olfaction.html">Advanced Olfaction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_ref/examples/path_integration.html">Path Integration</a></li>
<li class="toctree-l3"><a class="reference internal" href="../api_ref/examples/head_stabilization.html">Head Stabilization</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api_ref/legacy.html">Legacy API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workshop.html">NeuroMechFly Workshop</a></li>
<li class="toctree-l1"><a class="reference internal" href="../outreach.html">NeuroMechFly Live and Outreach</a></li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          <div class="view-this-page">
  <a class="muted-link" href="../_sources/tutorials/advanced_olfaction.rst.txt" title="View this page">
    <svg><use href="#svg-eye"></use></svg>
    <span class="visually-hidden">View this page</span>
  </a>
</div>
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto-light"><use href="#svg-sun-with-moon"></use></svg>
              <svg class="theme-icon-when-auto-dark"><use href="#svg-moon-with-sun"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main" id="furo-main-content">
          <section id="advanced-olfaction-navigating-a-complex-odor-plume">
<h1>Advanced olfaction: Navigating a complex odor plume<a class="headerlink" href="#advanced-olfaction-navigating-a-complex-odor-plume" title="Link to this heading">¶</a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>Author:</strong> Victor Alfred Stimpfling</p>
<p>The code presented in this notebook has been simplified and
restructured for display in a notebook format. A more complete and
better structured implementation can be found in the <a class="reference external" href="https://github.com/NeLy-EPFL/flygym/tree/main/flygym/examples/">examples folder of
the FlyGym repository on
GitHub</a>.</p>
<p>This tutorial is available in <code class="docutils literal notranslate"><span class="pre">.ipynb</span></code> format in the
<a class="reference external" href="https://github.com/NeLy-EPFL/flygym/tree/main/notebooks">notebooks folder of the FlyGym repository</a>.</p>
</div>
<p><strong>Summary</strong>: In this tutorial, we simulate a complex odor plume, replay
the plume in MuJoCo, and build a simple controller to navigate it.</p>
<p>We have shown, in <a class="reference external" href="https://neuromechfly.org/tutorials/olfaction.html">a previous
tutorial</a>, that
our model is able to navigate a static odor gradient. In nature, static
odor gradients are rather rare. On the contrary, dynamic plumes (c.f.
illustration from <a class="reference external" href="https://doi.org/10.7554/eLife.57524">Demir et al,
2020</a> below) with short
intermittent bursts are more common. In such environments, odor
gradients carry only limited information regarding the position of odor
source. Consequently, navigating an odor plume requires multimodal
integration of both wind and odor. In this notebook, we will demonstrate
how one can create an odor plume using
<a class="reference external" href="https://tum-pbs.github.io/PhiFlow/">PhiFlow</a>, a partial differential
equations solver designed for machine learning that solves the
Navier-Stokes equations to model the dynamics of a complex plume. We
will also show how this plume dataset can be plugged into NeuroMechFly.
Finally, we will design a very simple controller that can successfully
navigate a complex plume based on the algorithm proposed in <a class="reference external" href="https://doi.org/10.7554/eLife.57524">Demir et
al, 2020</a>.</p>
<a class="reference internal image-reference" href="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/demir_et_al_real_odour_plume.jpg?raw=true"><img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/demir_et_al_real_odour_plume.jpg?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/demir_et_al_real_odour_plume.jpg?raw=true" style="width: 500px;" />
</a>
<p><em>Image from Demir et al, 2020.</em></p>
<section id="simulating-a-complex-odor-plume">
<h2>Simulating a complex odor plume<a class="headerlink" href="#simulating-a-complex-odor-plume" title="Link to this heading">¶</a></h2>
<p>To demonstrate the flexibility of our framework, we will simulate an
arbitrary odor plume resembling those in <a class="reference external" href="https://doi.org/10.7554/eLife.57524">Demir et
al. 2020</a>. Our plume is modelled
as a distinct substance embedded in an incompressible fluid. This is
analogous to, for example, a food odor embedded in air. We simulate the
plume by solving the Navier—Stokes equations in 2D. Our simulation is
initialized with a constant velocity field, producing a right-bound
“wind”. In addition to the wind, we inject random perturbations as
external forces exerted on the smoke. The force vector moves in Brownian
motion, akin to random wind bursts driving turbulent flow.</p>
<p>Although we are simulating the plume in this tutorial, one can also
replay an experimentally recorded plume dataset.</p>
<p>To generate your own plume, make sure you have installed PhiFlow. This
should have been done already if you installed the “examples” optional
dependency of flygym (<code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">&quot;flygym[examples]&quot;</span></code>).</p>
<p>Let’s decide on a few hyperparameters defining our plume:</p>
<ul class="simple">
<li><p>The size of the arena</p></li>
<li><p>A scaling factor (i.e., spatial resolution) for the velocity and
smoke grids</p></li>
<li><p>The position and size of the inflow</p></li>
</ul>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># This notebook is partially based on the following script by  Felix Köhler:</span>
<span class="c1"># https://github.com/Ceyron/machine-learning-and-simulation/blob/main/english/phiflow/smoke_plume.py</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">h5py</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">phi.torch</span><span class="w"> </span><span class="kn">import</span> <span class="n">flow</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">trange</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="c1"># change the simulation time to have a shorter simulation</span>
<span class="n">simulation_time</span> <span class="o">=</span> <span class="mf">20.0</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.05</span>
<span class="n">arena_size</span> <span class="o">=</span> <span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
<span class="n">inflow_pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="n">inflow_radius</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">inflow_scaler</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">velocity_grid_size</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">smoke_grid_size</span> <span class="o">=</span> <span class="mf">0.25</span>
<span class="n">simulation_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">simulation_time</span> <span class="o">/</span> <span class="n">dt</span><span class="p">)</span>
</pre></div>
</div>
<p>Next we define the dynamics of the plume in more detail. In particular,
we load a helper function that outputs the Brownian contribution to the
total wind at every time step.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">converging_brownian_step</span><span class="p">(</span>
    <span class="n">value_curr</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">center</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">gaussian_scale</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">convergence</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Step to simulate Brownian noise with convergence towards a center.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value_curr : np.ndarray</span>
<span class="sd">        Current value of variables (i.e., noise) in Brownian motion.</span>
<span class="sd">    center : np.ndarray</span>
<span class="sd">        Center towards which the Brownian motion converges.</span>
<span class="sd">    gaussian_scale : float, optional</span>
<span class="sd">        Standard deviation of Gaussian noise to be added to the current</span>
<span class="sd">        value, by default 1.0</span>
<span class="sd">    convergence : float, optional</span>
<span class="sd">        Factor of convergence towards the center, by default 0.5.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        Next value of variables (i.e., noise) in Brownian motion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gaussian_center</span> <span class="o">=</span> <span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">value_curr</span><span class="p">)</span> <span class="o">*</span> <span class="n">convergence</span>
    <span class="n">value_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
        <span class="n">loc</span><span class="o">=</span><span class="n">gaussian_center</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">gaussian_scale</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">value_curr</span><span class="o">.</span><span class="n">shape</span>
    <span class="p">)</span>
    <span class="n">value_next</span> <span class="o">=</span> <span class="n">value_curr</span> <span class="o">+</span> <span class="n">value_diff</span>
    <span class="k">return</span> <span class="n">value_next</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flygym.examples.olfaction.simulate_plume_dataset</span><span class="w"> </span><span class="kn">import</span> <span class="n">converging_brownian_step</span>

<span class="c1"># Simulate Brownian noise and store the wind for every time step</span>
<span class="n">curr_wind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,))</span>
<span class="n">wind_hist</span> <span class="o">=</span> <span class="p">[</span><span class="n">curr_wind</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">simulation_steps</span><span class="p">):</span>
    <span class="n">curr_wind</span> <span class="o">=</span> <span class="n">converging_brownian_step</span><span class="p">(</span><span class="n">curr_wind</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">wind_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr_wind</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

<span class="c1"># Define simulation grids</span>
<span class="c1"># constant velocity vector in every points</span>
<span class="n">velocity</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">StaggeredGrid</span><span class="p">(</span>
    <span class="n">values</span><span class="o">=</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>  <span class="c1"># constant velocity field to the right</span>
    <span class="n">extrapolation</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">extrapolation</span><span class="o">.</span><span class="n">BOUNDARY</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">velocity_grid_size</span><span class="p">),</span>
    <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">velocity_grid_size</span><span class="p">),</span>
    <span class="n">bounds</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
<span class="p">)</span>

<span class="c1"># choose extrapolation mode from</span>
<span class="c1"># (&#39;undefined&#39;, &#39;zeros&#39;, &#39;boundary&#39;, &#39;periodic&#39;, &#39;symmetric&#39;, &#39;reflect&#39;)</span>
<span class="c1"># Zero smoke field at the beginning of the simulation</span>
<span class="n">smoke</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">CenteredGrid</span><span class="p">(</span>
    <span class="n">values</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="n">extrapolation</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">extrapolation</span><span class="o">.</span><span class="n">BOUNDARY</span><span class="p">,</span>
    <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">smoke_grid_size</span><span class="p">),</span>
    <span class="n">y</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">smoke_grid_size</span><span class="p">),</span>
    <span class="n">bounds</span><span class="o">=</span><span class="n">flow</span><span class="o">.</span><span class="n">Box</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
<span class="p">)</span>

<span class="c1"># Define inflow</span>
<span class="n">inflow</span> <span class="o">=</span> <span class="n">inflow_scaler</span> <span class="o">*</span> <span class="n">flow</span><span class="o">.</span><span class="n">field</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span>
    <span class="n">flow</span><span class="o">.</span><span class="n">Sphere</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">inflow_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">inflow_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="n">inflow_radius</span><span class="p">),</span>
    <span class="n">to</span><span class="o">=</span><span class="n">smoke</span><span class="p">,</span>
    <span class="n">soft</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Let’s visualize the velocity field, the smoke density, and the inflow at
the beginning of the simulation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">phi</span><span class="w"> </span><span class="kn">import</span> <span class="n">vis</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

<span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;outputs/plume_tracking&quot;</span><span class="p">)</span>
<span class="n">output_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Wind velocity&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;wind_velocity_t0.png&quot;</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">smoke</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Smoke density&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">show_color_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;smoke_density_t0.png&quot;</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">inflow</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Inflow&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">show_color_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;inflow_t0.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/wind_velocity_t0.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/wind_velocity_t0.png?raw=true" />
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/smoke_density_t0.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/smoke_density_t0.png?raw=true" />
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/inflow_t0.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/inflow_t0.png?raw=true" />
<p>Now we are ready to simulate the plume. For that we use the following
step function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span>
    <span class="n">velocity_prev</span><span class="p">:</span> <span class="n">flow</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
    <span class="n">smoke_prev</span><span class="p">:</span> <span class="n">flow</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span>
    <span class="n">noise</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">noise_magnitude</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">inflow</span><span class="p">:</span> <span class="n">flow</span><span class="o">.</span><span class="n">Grid</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">flow</span><span class="o">.</span><span class="n">Grid</span><span class="p">,</span> <span class="n">flow</span><span class="o">.</span><span class="n">Grid</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate fluid dynamics by one time step.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    velocity_prev : flow.Grid</span>
<span class="sd">        Velocity field at previous time step.</span>
<span class="sd">    smoke_prev : flow.Grid</span>
<span class="sd">        Smoke density at previous time step.</span>
<span class="sd">    noise : np.ndarray</span>
<span class="sd">        Brownian noise to be applied as external force.</span>
<span class="sd">    noise_magnitude : tuple[float, float], optional</span>
<span class="sd">        Magnitude of noise to be applied as external force in x and y</span>
<span class="sd">        directions, by default (0.1, 2)</span>
<span class="sd">    dt : float, optional</span>
<span class="sd">        Simulation time step, by default 1.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[flow.Grid, flow.Grid]</span>
<span class="sd">        Velocity field and smoke density at next time step.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">smoke_next</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">advect</span><span class="o">.</span><span class="n">mac_cormack</span><span class="p">(</span><span class="n">smoke_prev</span><span class="p">,</span> <span class="n">velocity_prev</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="n">inflow</span>
    <span class="n">external_force</span> <span class="o">=</span> <span class="n">smoke_next</span> <span class="o">*</span> <span class="n">noise</span> <span class="o">*</span> <span class="n">noise_magnitude</span> <span class="o">@</span> <span class="n">velocity_prev</span>
    <span class="n">velocity_tentative</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">flow</span><span class="o">.</span><span class="n">advect</span><span class="o">.</span><span class="n">semi_lagrangian</span><span class="p">(</span><span class="n">velocity_prev</span><span class="p">,</span> <span class="n">velocity_prev</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="o">+</span> <span class="n">external_force</span>
    <span class="p">)</span>
    <span class="n">velocity_next</span><span class="p">,</span> <span class="n">pressure</span> <span class="o">=</span> <span class="n">flow</span><span class="o">.</span><span class="n">fluid</span><span class="o">.</span><span class="n">make_incompressible</span><span class="p">(</span><span class="n">velocity_tentative</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">velocity_next</span><span class="p">,</span> <span class="n">smoke_next</span>
</pre></div>
</div>
<p>For every time step, we let the smoke advect in the velocity field and
add new smoke through the inflow. Then the velocity field (composed of
the previous wind and Brownian external noise) is self advected to get
the next velocity field and finally the pressures are projected using
the make incompressible function. The step function will be repeated to
unroll the full plume.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flygym.examples.olfaction.simulate_plume_dataset</span><span class="w"> </span><span class="kn">import</span> <span class="n">step</span>

<span class="c1"># Run fluid dynamics simulation</span>
<span class="n">smoke_hist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="n">simulation_steps</span><span class="p">):</span>
    <span class="n">velocity</span><span class="p">,</span> <span class="n">smoke</span> <span class="o">=</span> <span class="n">step</span><span class="p">(</span>
        <span class="n">velocity</span><span class="p">,</span>
        <span class="n">smoke</span><span class="p">,</span>
        <span class="n">wind_hist</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
        <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
        <span class="n">inflow</span><span class="o">=</span><span class="n">inflow</span><span class="p">,</span>
        <span class="n">noise_magnitude</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">smoke_vals</span> <span class="o">=</span> <span class="n">smoke</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">numpy</span><span class="p">(</span><span class="s2">&quot;y,x&quot;</span><span class="p">)</span>
    <span class="n">smoke_hist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">smoke_vals</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>100%|██████████| 400/400 [00:35&lt;00:00, 11.41it/s]
</pre></div>
</div>
<p>Because our time steps are much larger than that of the NeuroMechFly
physics simulation, we interpolate the smoke field. This is much faster
than running the plume simulation with smaller time steps:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>

<span class="n">sim_timepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulation_time</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
<span class="n">smoke_hist_interp_fun</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">sim_timepoints</span><span class="p">,</span> <span class="n">smoke_hist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">new_timepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">simulation_time</span> <span class="o">-</span> <span class="n">dt</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">10000</span><span class="p">)</span>
<span class="n">smoke_hist_interp</span> <span class="o">=</span> <span class="n">smoke_hist_interp_fun</span><span class="p">(</span><span class="n">new_timepoints</span><span class="p">)</span>
</pre></div>
</div>
<p>We will visualize the velocity field, the smoke density, and the inflow
at the end of the simulation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Wind velocity&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;wind_velocity_tf.png&quot;</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">smoke</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Smoke density&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">show_color_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;smoke_density_tf.png&quot;</span><span class="p">)</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">vis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">inflow</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Inflow&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">show_color_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;inflow_tf.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/wind_velocity_tf.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/wind_velocity_tf.png?raw=true" />
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/smoke_density_tf.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/smoke_density_tf.png?raw=true" />
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/inflow_tf.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/inflow_tf.png?raw=true" />
<p>Let’s save this plume dataset in the HDF5 format. HDF5 is an efficient
data format for saving arrays. Different from NumPy’s built-in formats
(NPY or NPZ), HDF5 allows partial reads of the dataset. In other words,
with NPZ:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;/path/to/file.npz&quot;</span><span class="p">)</span>  <span class="c1"># this reads the whole array from disk to RAM</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">my_iterator</span><span class="p">:</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># further slicing of data simply takes portions of the array from RAM</span>
</pre></div>
</div>
<p>… but with HDF5:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h5file</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s2">&quot;/path/to/file.hdf5&quot;</span><span class="p">)</span>  <span class="c1"># this only loads the metadata; data stays on disk</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="n">h5file</span><span class="p">[</span><span class="s2">&quot;key&quot;</span><span class="p">]</span>  <span class="c1"># HDF5 datasets are NumPy-array-like and can be accessed the same way</span>

<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">my_iterator</span><span class="p">:</span>
    <span class="n">part</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># only now is the *specified portion* of data loaded into RAM</span>
</pre></div>
</div>
<p>Therefore, at a slight cost of data loading overhead, we massively
reduce the RAM usage of our program (only the plume state at the current
time step is loaded into memory; the rest of the dataset remains on the
hard disk). Although this does not make a practical difference in this
tutorial, it become important if we want to run multiple long
simulations in parallel. More information about the HDF5 data format can
be found <a class="reference external" href="https://docs.h5py.org/en/stable/quick.html">here</a>.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume.hdf5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;plume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">smoke_hist_interp</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inflow_pos</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">inflow_radius</span><span class="p">]</span>  <span class="c1"># save as array with a single value</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_scaler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">inflow_scaler</span><span class="p">]</span>  <span class="c1"># &quot;</span>
</pre></div>
</div>
</section>
<section id="creating-a-plume-within-an-arena">
<h2>Creating a plume within an arena<a class="headerlink" href="#creating-a-plume-within-an-arena" title="Link to this heading">¶</a></h2>
<p>The next step is to create an environment in which the fly can navigate
the plume. For the sake of simplicity, here the pre-recorded plume is
simply replayed and does not physically interact with the fly.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">OdorPlumeArena</span></code> class implements all the necessary functions to
obtain sensory input from the plume and resample the plume to the size
of the arena. In our plume simulation, the smoke grid has a spatial
resolution of <span class="math notranslate nohighlight">\(\Delta x_\text{smoke} = 0.25\)</span> units in an arena of
size <span class="math notranslate nohighlight">\((X_\text{max}, Y_\text{max})\)</span> units. We allow the user to
define how this grid is scaled to the physical arena using a dimensional
scale parameter <span class="math notranslate nohighlight">\(s\)</span>: the size of the arena that the fly walks in
is given by
<span class="math notranslate nohighlight">\(s(X_\text{max}, Y_\text{max}) / \Delta x_\text{smoke}\)</span> mm. For
example, at <span class="math notranslate nohighlight">\(s=0.5\)</span>, the size of the arena is
<span class="math notranslate nohighlight">\(0.5 \times (80, 60) / 0.25 = (160, 120)\)</span> mm. Similarly, the user
can specify the speed at which the plume simulation is played out by
setting the FPS of the plume dataset. These parameters are managed as
follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">OdorPlumeArena</span><span class="p">(</span><span class="n">BaseArena</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This Arena class provides an interface to the separately simulated</span>
<span class="sd">    odor plume. The plume simulation is stored in an HDF5 file. In this</span>
<span class="sd">    class, we implement logics that calculate the intensity of the odor</span>
<span class="sd">    at the fly&#39;s location at the correct time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
         <span class="bp">self</span><span class="p">,</span>
         <span class="n">plume_data_path</span><span class="p">:</span> <span class="n">Path</span><span class="p">,</span>
         <span class="n">main_camera_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
         <span class="n">dimension_scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
         <span class="n">plume_simulation_fps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
         <span class="n">intensity_scale_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
         <span class="n">friction</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">),</span>
         <span class="n">num_sensors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
     <span class="p">):</span>
<span class="w">         </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Parameters</span>
<span class="sd">         ----------</span>
<span class="sd">         plume_data_path : Path</span>
<span class="sd">             Path to the HDF5 file containing the plume simulation data.</span>
<span class="sd">         main_camera_name : str</span>
<span class="sd">             Name of the main camera used to render the plume simulation.</span>
<span class="sd">         dimension_scale_factor : float, optional</span>
<span class="sd">             Scaling factor for the plume simulation grid. Each cell in the</span>
<span class="sd">             plume grid is this many millimeters in the simulation. By</span>
<span class="sd">             default 0.5.</span>
<span class="sd">         plume_simulation_fps : float, optional</span>
<span class="sd">             Frame rate of the plume simulation. Each frame in the plume</span>
<span class="sd">             dataset is ``1 / plume_simulation_fps`` seconds in the physics</span>
<span class="sd">             simulation. By default 200.</span>
<span class="sd">         intensity_scale_factor : float, optional</span>
<span class="sd">             Scaling factor for the intensity of the odor. By default 1.0.</span>
<span class="sd">         friction : Tuple[float, float, float], optional</span>
<span class="sd">             Friction parameters for the floor geom. By default (1, 0.005,</span>
<span class="sd">             0.0001).</span>
<span class="sd">         num_sensors : int, optional</span>
<span class="sd">             Number of olfactory sensors on the fly. By default 4.</span>
<span class="sd">         &quot;&quot;&quot;</span>

            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dimension_scale_factor</span> <span class="o">=</span> <span class="n">dimension_scale_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plume_simulation_fps</span> <span class="o">=</span> <span class="n">plume_simulation_fps</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">intensity_scale_factor</span> <span class="o">=</span> <span class="n">intensity_scale_factor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">friction</span> <span class="o">=</span> <span class="n">friction</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_sensors</span> <span class="o">=</span> <span class="n">num_sensors</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curr_time</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plume_update_interval</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">plume_simulation_fps</span>

            <span class="c1"># Load plume data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plume_dataset</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">plume_data_path</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plume_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plume_dataset</span><span class="p">[</span><span class="s2">&quot;plume&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plume_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dimension_scale_factor</span>
            <span class="p">)</span>

            <span class="c1"># Set up floor</span>
            <span class="n">floor_material</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_element</span><span class="o">.</span><span class="n">asset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="s2">&quot;material&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;floor_material&quot;</span><span class="p">,</span>
                <span class="n">reflectance</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">shininess</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">specular</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">rgba</span><span class="o">=</span><span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_element</span><span class="o">.</span><span class="n">worldbody</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
                <span class="s2">&quot;geom&quot;</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s2">&quot;floor&quot;</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">pos</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                <span class="n">material</span><span class="o">=</span><span class="n">floor_material</span><span class="p">,</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>We will also implement a function that reads out the odor intensity for
every sensor from the simulated smoke grid:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_olfaction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">antennae_pos</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the olfactory input for the given antennae positions. If</span>
<span class="sd">        the fly is outside the plume simulation grid, returns np.nan.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the current frame of the plume</span>
        <span class="n">frame_num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_time</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">plume_simulation_fps</span><span class="p">)</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sensors</span> <span class="o">==</span> <span class="n">antennae_pos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">odor_dimensions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sensors</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i_sensor</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sensors</span><span class="p">):</span>
            <span class="c1"># get the sensor position in mm (from the physics)</span>
            <span class="n">x_mm</span><span class="p">,</span> <span class="n">y_mm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">antennae_pos</span><span class="p">[</span><span class="n">i_sensor</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># map to our simulated plume dimensions</span>
            <span class="n">x_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_mm</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_scale_factor</span><span class="p">)</span>
            <span class="n">y_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_mm</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dimension_scale_factor</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">x_idx</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">y_idx</span> <span class="o">&lt;</span> <span class="mi">0</span>
                <span class="ow">or</span> <span class="n">x_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plume_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="ow">or</span> <span class="n">y_idx</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plume_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="n">intensities</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i_sensor</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">intensities</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i_sensor</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plume_grid</span><span class="p">[</span><span class="n">frame_num</span><span class="p">,</span> <span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">intensities</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">intensity_scale_factor</span>
</pre></div>
</div>
<p>Finally, we will implement a function to get the position mapping
between the bird’s eye camera and indices in the simulated plume grid.
This will become very handy when we want to project the simulated plume
onto the arena for proper rendering.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">get_position_mapping</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">:</span> <span class="n">Simulation</span><span class="p">,</span> <span class="n">camera_id</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;birdeye_cam&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the display location (row-col coordinates) of each pixel in</span>
<span class="sd">        the fluid dynamics simulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sim : Simulation</span>
<span class="sd">            Simulation simulation object.</span>
<span class="sd">        camera_id : str, optional</span>
<span class="sd">            Camera to build position mapping for, by default &quot;birdeye_cam&quot;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pos_display: np.ndarray</span>
<span class="sd">            Array of shape (n_row_pxls_plume, n_col_pxls_plume, 2)</span>
<span class="sd">            containing the row-col coordinates of each plume simulation</span>
<span class="sd">            cell on the **display** image (in pixels).</span>
<span class="sd">        pos_physical: np.ndarray</span>
<span class="sd">            Array of shape (n_row_pxls_plume, n_col_pxls_plume, 2)</span>
<span class="sd">            containing the row-col coordinates of each plume simulation</span>
<span class="sd">            cell on the **physical** simulated grid (in mm). This is a</span>
<span class="sd">            regular lattice grid marking the physical position of the</span>
<span class="sd">            *centers* of the fluid simulation cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">birdeye_cam_dm_control_obj</span> <span class="o">=</span> <span class="n">Camera</span><span class="p">(</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">physics</span><span class="p">,</span>
            <span class="n">camera_id</span><span class="o">=</span><span class="n">camera_id</span><span class="p">,</span>
            <span class="n">width</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">height</span><span class="o">=</span><span class="n">sim</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">camera_matrix</span> <span class="o">=</span> <span class="n">birdeye_cam_dm_control_obj</span><span class="o">.</span><span class="n">matrix</span>
        <span class="c1"># Get the center of every grid cell</span>
        <span class="n">xs_physical</span><span class="p">,</span> <span class="n">ys_physical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># project those centers to the camera coordinates</span>
        <span class="n">xyz1_vecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">xs_physical</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">xyz1_vecs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xs_physical</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">xyz1_vecs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ys_physical</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">xyz1_vecs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pos_physical</span> <span class="o">=</span> <span class="n">xyz1_vecs</span><span class="p">[:,</span> <span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">xs_physical</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">xs_display</span><span class="p">,</span> <span class="n">ys_display</span><span class="p">,</span> <span class="n">display_scale</span> <span class="o">=</span> <span class="n">camera_matrix</span> <span class="o">@</span> <span class="n">xyz1_vecs</span><span class="o">.</span><span class="n">T</span>
        <span class="n">xs_display</span> <span class="o">/=</span> <span class="n">display_scale</span>
        <span class="n">ys_display</span> <span class="o">/=</span> <span class="n">display_scale</span>
        <span class="n">pos_display</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xs_display</span><span class="p">,</span> <span class="n">ys_display</span><span class="p">))</span>
        <span class="n">pos_display</span> <span class="o">=</span> <span class="n">pos_display</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">xs_physical</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pos_display</span><span class="p">,</span> <span class="n">pos_physical</span>
</pre></div>
</div>
<p>We will create an <code class="docutils literal notranslate"><span class="pre">OdorPlumeArena</span></code> instance. For the sake of
demonstration, we will use a dimensional scale factor of 0.25 and a very
high plume FPS to make the simulation easier to run.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flygym.examples.olfaction.plume_tracking_arena</span><span class="w"> </span><span class="kn">import</span> <span class="n">OdorPlumeArena</span>

<span class="n">main_camera_name</span> <span class="o">=</span> <span class="s2">&quot;birdeye_camera&quot;</span>
<span class="n">arena</span> <span class="o">=</span> <span class="n">OdorPlumeArena</span><span class="p">(</span>
    <span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume.hdf5&quot;</span><span class="p">,</span> <span class="n">main_camera_name</span><span class="o">=</span><span class="n">main_camera_name</span><span class="p">,</span>
    <span class="n">plume_simulation_fps</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="n">dimension_scale_factor</span><span class="o">=</span><span class="mf">0.25</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Now, we are ready to implement the main simulation loop. We will make
the fly stand still for the sake of this demonstration:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flygym</span><span class="w"> </span><span class="kn">import</span> <span class="n">Fly</span><span class="p">,</span> <span class="n">SingleFlySimulation</span><span class="p">,</span> <span class="n">Camera</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flygym.examples.locomotion</span><span class="w"> </span><span class="kn">import</span> <span class="n">PreprogrammedSteps</span>

<span class="n">timestep</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="n">run_time</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="c1"># Initialize fly simulation</span>
<span class="n">fly</span> <span class="o">=</span> <span class="n">Fly</span><span class="p">(</span>
    <span class="n">enable_olfaction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">spawn_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">60.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span>
    <span class="n">spawn_orientation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">cam_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mode&quot;</span><span class="p">:</span><span class="s2">&quot;fixed&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="mf">0.50</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="mf">0.15</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="mf">1.00</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">),</span>
    <span class="s2">&quot;euler&quot;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;fovy&quot;</span><span class="p">:</span><span class="mi">60</span><span class="p">}</span>

<span class="n">cam</span> <span class="o">=</span> <span class="n">Camera</span><span class="p">(</span>
    <span class="n">attachment_point</span><span class="o">=</span><span class="n">arena</span><span class="o">.</span><span class="n">root_element</span><span class="o">.</span><span class="n">worldbody</span><span class="p">,</span>
    <span class="n">camera_name</span><span class="o">=</span><span class="n">main_camera_name</span><span class="p">,</span>
    <span class="n">timestamp_text</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">camera_parameters</span><span class="o">=</span><span class="n">cam_params</span>
<span class="p">)</span>
<span class="n">sim</span> <span class="o">=</span> <span class="n">SingleFlySimulation</span><span class="p">(</span><span class="n">fly</span><span class="o">=</span><span class="n">fly</span><span class="p">,</span> <span class="n">arena</span><span class="o">=</span><span class="n">arena</span><span class="p">,</span> <span class="n">cameras</span><span class="o">=</span><span class="p">[</span><span class="n">cam</span><span class="p">])</span>

<span class="n">preprogrammed_step</span> <span class="o">=</span> <span class="n">PreprogrammedSteps</span><span class="p">()</span>
<span class="n">standing_joint_angles</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">preprogrammed_step</span><span class="o">.</span><span class="n">legs</span><span class="p">:</span>
    <span class="n">standing_joint_angles</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">preprogrammed_step</span><span class="o">.</span><span class="n">get_joint_angles</span><span class="p">(</span><span class="n">leg</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>

<span class="n">target_num_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">run_time</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span>
<span class="n">obs_list</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="n">target_num_steps</span><span class="p">):</span>
    <span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">terminated</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span>
        <span class="n">action</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;joints&quot;</span><span class="p">:</span> <span class="n">standing_joint_angles</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="n">obs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>100%|██████████| 10000/10000 [00:19&lt;00:00, 503.42it/s]
</pre></div>
</div>
<p>Let’s plot the time series of the odor intensities sensed by the fly’s
olfactory sensory organs:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">odor_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;odor_intensity&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">obs_list</span><span class="p">])</span>
<span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">run_time</span><span class="p">,</span> <span class="n">timestep</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">tight_layout</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">odor_intensities</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(),</span> <span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Odor intensity (a.u.)&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Odor intensity sensed by the fly&quot;</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="p">[</span><span class="n">sensor</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">sensor</span> <span class="ow">in</span> <span class="n">fly</span><span class="o">.</span><span class="n">_antennae_sensors</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;odor_intensity_ts.png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<img alt="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/odor_intensity_ts.png?raw=true" src="https://github.com/NeLy-EPFL/_media/blob/main/flygym/plume_tracking/odor_intensity_ts.png?raw=true" />
<p>We can also generate a video of the simulation:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cam</span><span class="o">.</span><span class="n">save_video</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;sim_static.mp4&quot;</span><span class="p">)</span>
</pre></div>
</div>
<video src="https://raw.githubusercontent.com/NeLy-EPFL/_media/main/flygym/plume_tracking/sim_static.mp4" controls="controls" style="max-width: 400px;"></video><p>But we don’t see the plume here! This is because we are simply reading
out the appropriate values from the pre-generated plume dataset. The
odor is not actually added or visualized in any way in the NeuroMechFly
physics simulation. In the next section, we will build another layer of
abstraction that overlays the image of the plume onto the rendered image
for visualization.</p>
</section>
<section id="plume-tracking-task">
<h2>Plume tracking task<a class="headerlink" href="#plume-tracking-task" title="Link to this heading">¶</a></h2>
<p>By now, we have implemented an odor plume arena that replays the
simulated plume. The fly can walk in this arena and experience
intermittent bursts of odor. We will now implement a wrapper for the
plume tracking task. In this layer of abstraction, we will implement the
following functionalities:</p>
<ol class="arabic simple">
<li><p>Overlay the plume on top of the rendered image.</p></li>
<li><p>Truncate the simulation when the fly walks out of bound.</p></li>
</ol>
<p>Recall <a class="reference external" href="https://neuromechfly.org/tutorials/gym_basics_and_kinematic_replay.html#markov-decision-process-mdp-and-the-gym-api">the construction of the Markov Decision Process
(MDP)</a>.
The task that we are implementing is the Task/Environment under the MPD
framework. Therefore, it is an <code class="docutils literal notranslate"><span class="pre">Env</span></code> in the Gymnasium interface. We
will extend the <code class="docutils literal notranslate"><span class="pre">HybridTurningController</span></code> environment for this
purpose.</p>
<p>We start with the <code class="docutils literal notranslate"><span class="pre">__init__</span></code> method. Here, we use the
<code class="docutils literal notranslate"><span class="pre">get_position_mapping</span></code> function that we have implemented for
<code class="docutils literal notranslate"><span class="pre">OdorPlumeArena</span></code> to find the following for each element in the odor
simulation grid:</p>
<ol class="arabic simple">
<li><p>The row-column position of it on the image rendered by the camera.</p></li>
<li><p>The x-y position, in mm, of the physical spot where the center of
cell is on the smoke grid.</p></li>
</ol>
<p>Then, we will interpolate these points in 2D so that for every pixel
displayed on the camera’s output, we know which cell it corresponds to
on the plume grid and what the x-y coordinates are in the physical
arena.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">PlumeNavigationTask</span><span class="p">(</span><span class="n">HybridTurningController</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper around the ``HybridTurningController`` that implements logics</span>
<span class="sd">    and utilities related to plume tracking such as overlaying the plume</span>
<span class="sd">    onto the rendered images. It also checks if the fly is within the plume</span>
<span class="sd">    simulation grid and truncates the simulation accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fly</span><span class="p">:</span> <span class="n">Fly</span><span class="p">,</span>
        <span class="n">arena</span><span class="p">:</span> <span class="n">OdorPlumeArena</span><span class="p">,</span>
        <span class="n">render_plume_alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">intensity_display_vmax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fly: Fly</span>
<span class="sd">            The fly object to be used. See</span>
<span class="sd">            ``flygym.example.locomotion.HybridTurningController``.</span>
<span class="sd">        arena: OdorPlumeArena</span>
<span class="sd">            The odor plume arena object to be used. Initialize it before</span>
<span class="sd">            creating the ``PlumeNavigationTask`` object.</span>
<span class="sd">        render_plume_alpha : float</span>
<span class="sd">            The transparency of the plume overlay on the rendered images.</span>
<span class="sd">        intensity_display_vmax : float</span>
<span class="sd">            The maximum intensity value to be displayed on the rendered</span>
<span class="sd">            images.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">fly</span><span class="o">=</span><span class="n">fly</span><span class="p">,</span> <span class="n">arena</span><span class="o">=</span><span class="n">arena</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">arena</span> <span class="o">=</span> <span class="n">arena</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plume_last_update_time</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_plume_img</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_render_plume_alpha</span> <span class="o">=</span> <span class="n">render_plume_alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_display_vmax</span> <span class="o">=</span> <span class="n">intensity_display_vmax</span>

        <span class="c1"># Find out where on the displayed images the plume simulation grid</span>
        <span class="c1"># should be overlaid. In other words, interpolate the mapping from</span>
        <span class="c1"># displayed pixel positions to simulated physical positions.</span>
        <span class="n">pos_display_sample</span><span class="p">,</span> <span class="n">pos_physical_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">get_position_mapping</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">camera_id</span><span class="o">=</span><span class="s2">&quot;birdeye_cam&quot;</span>
        <span class="p">)</span>
        <span class="n">pos_display_sample</span> <span class="o">=</span> <span class="n">pos_display_sample</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">pos_physical_sample</span> <span class="o">=</span> <span class="n">pos_physical_sample</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">LinearNDInterpolator</span><span class="p">(</span>
            <span class="n">pos_display_sample</span><span class="p">,</span> <span class="n">pos_physical_sample</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="p">)</span>
        <span class="n">xs_display</span><span class="p">,</span> <span class="n">ys_display</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="n">pos_display_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">xs_display</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">ys_display</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">pos_physical_all</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">pos_display_all</span><span class="p">)</span>
        <span class="n">pos_physical_all</span> <span class="o">=</span> <span class="n">pos_physical_all</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">grid_idx_all</span> <span class="o">=</span> <span class="n">pos_physical_all</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">dimension_scale_factor</span>
        <span class="n">grid_idx_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">grid_idx_all</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># self.grid_idx_all has the shape (cam_nrows, cam_ncols, 2) and</span>
        <span class="c1"># indicates the (x, y) indices of the plume simulation grid cell.</span>
        <span class="c1"># When the index is -1, this point on the displayed image is out of</span>
        <span class="c1"># the simulated arena.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_idx_all</span> <span class="o">=</span> <span class="n">grid_idx_all</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">focus_cam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_cam</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fc_width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc_height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">focus_cam</span><span class="o">.</span><span class="n">window_size</span>
            <span class="n">pixel_meshgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_width</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_height</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pixel_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span>
                <span class="p">[</span><span class="n">pixel_meshgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">pixel_meshgrid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
            <span class="p">)</span>
</pre></div>
</div>
<p>To override the <code class="docutils literal notranslate"><span class="pre">render</span></code> method, we just need to get the plume image
corresponding to the current time point and overlay it on top of the
camera image. We also add a bar indicating the mean intensity to the
bottom image for better visualization.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">rendered_img</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">rendered_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">rendered_img</span><span class="p">]</span>  <span class="c1"># no image rendered</span>

    <span class="c1"># Overlay plume</span>
    <span class="n">time_since_last_update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_time</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plume_last_update_time</span>
    <span class="n">update_needed</span> <span class="o">=</span> <span class="n">time_since_last_update</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">plume_update_interval</span>
    <span class="k">if</span> <span class="n">update_needed</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_plume_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_time</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">plume_simulation_fps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cached_plume_img</span> <span class="o">=</span> <span class="n">_resample_plume_image</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_idx_all</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arena</span><span class="o">.</span><span class="n">plume_grid</span><span class="p">[</span><span class="n">t_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_plume_last_update_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_time</span>
    <span class="n">plume_img</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cached_plume_img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_render_plume_alpha</span>
    <span class="n">plume_img</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">plume_img</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">rendered_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">rendered_img</span> <span class="o">-</span> <span class="n">plume_img</span> <span class="o">*</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

    <span class="c1"># Add intensity indicator</span>
    <span class="n">mean_intensity</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_observation</span><span class="p">()[</span><span class="s2">&quot;odor_intensity&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
    <span class="n">mean_intensity_relative</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span>
        <span class="n">mean_intensity</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intensity_display_vmax</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">rmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10</span>
    <span class="n">rmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cmin</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cmax</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">mean_intensity_relative</span><span class="p">)</span>
    <span class="n">rendered_img</span><span class="p">[</span><span class="n">rmin</span><span class="p">:</span><span class="n">rmax</span><span class="p">,</span> <span class="n">cmin</span><span class="p">:</span><span class="n">cmax</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Replace recorded image with modified one</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cameras</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rendered_img</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">rendered_img</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s just define a fly, an arena and a camera to start with.</p>
<p>The actual <code class="docutils literal notranslate"><span class="pre">_resample_plume_image</span></code> function is accelerated with
<a class="reference external" href="https://numba.pydata.org/">Numba</a>. This is because we need to
iterate every pixel to modify its value, and loops in native, uncompiled
Python <a class="reference external" href="https://stackoverflow.com/questions/8097408/why-python-is-so-slow-for-a-simple-for-loop">are extremely
slow</a>.
With Numba’s <code class="docutils literal notranslate"><span class="pre">njit</span></code> <a class="reference external" href="https://peps.python.org/pep-0318/">decorator</a>,
we can compile the Python code into LLVM — a low-level code that
directly interfaces with the CPU through backends — just in time (hence
the “JIT” in <code class="docutils literal notranslate"><span class="pre">njit</span></code>). Furthermore, we will force Numba to do this in a
“no-Python” way (hence the “N” in <code class="docutils literal notranslate"><span class="pre">njit</span></code>) to ensure fast execution.
These changes give us C-like performance in the render function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">njit</span>

<span class="nd">@njit</span><span class="p">(</span><span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_resample_plume_image</span><span class="p">(</span><span class="n">grid_idx_all</span><span class="p">,</span> <span class="n">plume_grid</span><span class="p">):</span>
    <span class="n">plume_img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">grid_idx_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">grid_idx_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">prange</span><span class="p">(</span><span class="n">grid_idx_all</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">x_idx</span> <span class="o">=</span> <span class="n">grid_idx_all</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y_idx</span> <span class="o">=</span> <span class="n">grid_idx_all</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">x_idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">plume_img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">plume_grid</span><span class="p">[</span><span class="n">y_idx</span><span class="p">,</span> <span class="n">x_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">plume_img</span>
</pre></div>
</div>
<p>To truncate the simulation when the fly moves out of bounds, we can
simply set the <code class="docutils literal notranslate"><span class="pre">truncate</span></code> flag — returned by the <code class="docutils literal notranslate"><span class="pre">step</span></code> method of
any Gymnasium environment — to <code class="docutils literal notranslate"><span class="pre">True</span></code>. Recall that we have already
implemented a logic in the <code class="docutils literal notranslate"><span class="pre">OdorPlumeArena</span></code> that returns NaN when the
queried position is out of bounds. Therefore,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
    <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">terminated</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">action</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;odor_intensity&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">truncated</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">terminated</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span>
</pre></div>
</div>
<p>Let’s run a sample simulation where the fly walks blindly forward:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">flygym.examples.olfaction</span><span class="w"> </span><span class="kn">import</span> <span class="n">PlumeNavigationTask</span>

<span class="n">arena</span> <span class="o">=</span> <span class="n">OdorPlumeArena</span><span class="p">(</span>
    <span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume.hdf5&quot;</span><span class="p">,</span> <span class="n">plume_simulation_fps</span><span class="o">=</span><span class="mi">8000</span><span class="p">,</span> <span class="n">dimension_scale_factor</span><span class="o">=</span><span class="mf">0.25</span>
<span class="p">)</span>

<span class="n">contact_sensor_placements</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">leg</span><span class="si">}{</span><span class="n">segment</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LF&quot;</span><span class="p">,</span> <span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="s2">&quot;LH&quot;</span><span class="p">,</span> <span class="s2">&quot;RF&quot;</span><span class="p">,</span> <span class="s2">&quot;RM&quot;</span><span class="p">,</span> <span class="s2">&quot;RH&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Tibia&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus1&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus2&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus3&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus4&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus5&quot;</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">fly</span> <span class="o">=</span> <span class="n">Fly</span><span class="p">(</span>
    <span class="n">enable_adhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">draw_adhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">enable_olfaction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">enable_vision</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">contact_sensor_placements</span><span class="o">=</span><span class="n">contact_sensor_placements</span><span class="p">,</span>
    <span class="n">spawn_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">60.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span>
    <span class="n">spawn_orientation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
<span class="p">)</span>
<span class="n">cam_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mode&quot;</span><span class="p">:</span><span class="s2">&quot;fixed&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="mf">0.50</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="mf">0.15</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="mf">1.00</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">),</span>
    <span class="s2">&quot;euler&quot;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;fovy&quot;</span><span class="p">:</span><span class="mi">60</span><span class="p">}</span>

<span class="n">cam</span> <span class="o">=</span> <span class="n">Camera</span><span class="p">(</span>
    <span class="n">attachment_point</span><span class="o">=</span><span class="n">arena</span><span class="o">.</span><span class="n">root_element</span><span class="o">.</span><span class="n">worldbody</span><span class="p">,</span>
    <span class="n">camera_name</span><span class="o">=</span><span class="n">main_camera_name</span><span class="p">,</span>
    <span class="n">timestamp_text</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">camera_parameters</span><span class="o">=</span><span class="n">cam_params</span>
<span class="p">)</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">PlumeNavigationTask</span><span class="p">(</span>
    <span class="n">fly</span><span class="o">=</span><span class="n">fly</span><span class="p">,</span>
    <span class="n">arena</span><span class="o">=</span><span class="n">arena</span><span class="p">,</span>
    <span class="n">cameras</span><span class="o">=</span><span class="p">[</span><span class="n">cam</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">sim</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="n">straight_dn_drive</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="n">target_num_steps</span><span class="p">):</span>
    <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">terminated</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">straight_dn_drive</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">render</span><span class="p">()</span>

<span class="n">cam</span><span class="o">.</span><span class="n">save_video</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume_display.mp4&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>100%|██████████| 10000/10000 [00:33&lt;00:00, 298.85it/s]
</pre></div>
</div>
<video src="https://raw.githubusercontent.com/NeLy-EPFL/_media/main/flygym/plume_tracking/plume_display.mp4" controls="controls" style="max-width: 400px;"></video></section>
<section id="implementing-a-plume-tracking-controller">
<h2>Implementing a plume tracking controller<a class="headerlink" href="#implementing-a-plume-tracking-controller" title="Link to this heading">¶</a></h2>
<p>Having implemented the MDP task for plume tracking, we are finally ready
to build a plume following controller. We propose a model where the fly
walks crosswind when little odor evidence is accumulated and upwind when
encountering a lot of odor packets. The crosswind direction is random
and biased by the encounter history during crosswind walks.</p>
<p>It takes time for the first plume burst to reach the fly. We will crop
the first half of the plume simulation so that the plume reaches the fly
immediately. This is merely to shorten the simulation in this tutorial
and is optional.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">time_cropped_plume</span> <span class="o">=</span> <span class="n">smoke_hist_interp</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span>

<span class="c1"># lets crop a few frames from the plume simulation</span>
<span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume_tcropped.hdf5&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;plume&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">time_cropped_plume</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_pos&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inflow_pos</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inflow_radius</span>
    <span class="n">f</span><span class="p">[</span><span class="s2">&quot;inflow_scaler&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">inflow_scaler</span>
</pre></div>
</div>
<p>We implement the plume navigation controller as follows. Our controller
accumulates odor evidence during a fixed interval of time. The
accumulated evidence increases with odor encounters and decreases with
time. From accumulated evidence, we derive the angle of wind direction.
The more evidence accumulated, the more likely it is that the fly will
head upwind. It heads more randomly, i.e., more crosswind, when no
evidence is accumulated. When the target angle is defined, the
descending drive is regularly updated to match the target angle. See
<a class="reference external" href="https://doi.org/10.7554/eLife.57524">Demir et al, 2020</a> or our
NeuroMechFly v2 paper for more details.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cv2</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">flygym.util</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_data_path</span>


<span class="k">class</span><span class="w"> </span><span class="nc">WalkingState</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">FORWARD</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">TURN_LEFT</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">TURN_RIGHT</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">STOP</span> <span class="o">=</span> <span class="mi">3</span>


<span class="c1"># get the angle of the vector in world coordinates</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_vector_angle</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>


<span class="c1"># change an array to a set of probabilities (sum to 1)</span>
<span class="c1"># this is used to bias crosswind walking</span>
<span class="k">def</span><span class="w"> </span><span class="nf">to_probability</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># the difference between the two values reflects</span>
    <span class="c1"># the probability of each entry</span>
    <span class="n">x</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SimplePlumeNavigationController</span><span class="p">:</span>
    <span class="c1"># defines a very simple controller to navigate the odor plume</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timestep</span><span class="p">,</span> <span class="n">wind_dir</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span> <span class="o">=</span> <span class="n">timestep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wind_dir</span> <span class="o">=</span> <span class="n">wind_dir</span>

        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>

        <span class="c1"># define the dn drives for each state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">WalkingState</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]),</span>
            <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_LEFT</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">)),</span>
            <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_RIGHT</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">)),</span>
            <span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)),</span>
        <span class="p">}</span>

        <span class="c1"># evidence accumulation parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_decay</span> <span class="o">=</span> <span class="mf">0.0001</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_odor_gain</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_threshold</span> <span class="o">=</span> <span class="mf">20.0</span>

        <span class="c1"># decision making parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_decision_interval</span> <span class="o">=</span> <span class="mf">0.75</span>  <span class="c1"># s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">since_last_decision_time</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># minimal evidence value during a decision interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_evidence</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_decay</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_decision_interval</span> <span class="o">/</span> <span class="n">timestep</span>
        <span class="p">)</span>

        <span class="c1"># descending neuron drive parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive_update_interval</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive_update_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dn_drive_update_interval</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span><span class="p">]</span>

        <span class="c1"># controller state parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_state</span> <span class="o">=</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># boundary checking parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_refractory_period</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_target_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the target angle to the wind based on the accumulated evidence, the wind direction</span>
<span class="sd">        and the history of success in the crosswind direction</span>
<span class="sd">        The target angle is more upwind if the accumulated evidence is high</span>
<span class="sd">        and more crosswind if the accumulated evidence is low</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        target_angle : float</span>
<span class="sd">            The target angle to the wind (in radian)</span>
<span class="sd">        to_upwind_angle : float</span>
<span class="sd">            The angle to the upwind direction (in radian)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">up_wind_angle</span> <span class="o">=</span> <span class="n">get_vector_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wind_dir</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="c1"># the angle to the wind is defined by the accumulated evidence:</span>
        <span class="c1">#   - if little evidence, the fly will go crosswind (angle to upwind = np.pi/2)</span>
        <span class="c1">#   - if a lots of evidence, the fly will go upwind (angle to upwind = 0)</span>
        <span class="n">to_upwind_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">4</span>
        <span class="n">crosswind_success_proba</span> <span class="o">=</span> <span class="n">to_probability</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">)</span>

        <span class="c1"># randomize the sign of the angle depending on the history of success</span>
        <span class="n">to_upwind_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">crosswind_success_proba</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
            <span class="n">to_upwind_angle</span>
        <span class="p">)</span>

        <span class="c1"># compute the target angle (the up wind angle + the angle to upwind direction)</span>
        <span class="n">target_angle</span> <span class="o">=</span> <span class="n">up_wind_angle</span> <span class="o">+</span> <span class="n">to_upwind_angle</span>
        <span class="k">if</span> <span class="n">target_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">target_angle</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">target_angle</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">target_angle</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="n">target_angle</span><span class="p">,</span> <span class="n">to_upwind_angle</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">angle_to_dn_drive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fly_orientation</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compare the fly&#39;s orientation to the target angle and return the</span>
<span class="sd">        descending drive that will make the fly go in the correct direction</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fly_orientation : np.array</span>
<span class="sd">            The fly orientation vector</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dn_drive : np.array</span>
<span class="sd">            The dn drive that will make the fly go in the correct direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fly_angle</span> <span class="o">=</span> <span class="n">get_vector_angle</span><span class="p">(</span><span class="n">fly_orientation</span><span class="p">)</span>
        <span class="n">angle_diff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_angle</span> <span class="o">-</span> <span class="n">fly_angle</span>
        <span class="k">if</span> <span class="n">angle_diff</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">angle_diff</span> <span class="o">-=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">elif</span> <span class="n">angle_diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">:</span>
            <span class="n">angle_diff</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_angle</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span><span class="p">],</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span>
        <span class="k">elif</span> <span class="n">angle_diff</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_LEFT</span><span class="p">],</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_LEFT</span>
        <span class="k">elif</span> <span class="n">angle_diff</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_RIGHT</span><span class="p">],</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_RIGHT</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="n">WalkingState</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">],</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">FORWARD</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fly_orientation</span><span class="p">,</span> <span class="n">odor_intensities</span><span class="p">,</span> <span class="n">close_to_boundary</span><span class="p">,</span> <span class="n">curr_time</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Step the controller:</span>
<span class="sd">          - Check if the fly is close to the boundary</span>
<span class="sd">          - Accumulate evidence</span>
<span class="sd">          - Update the target angle if:</span>
<span class="sd">            - the accumulated evidence is high</span>
<span class="sd">            - the decision interval is reached</span>
<span class="sd">            - the fly is close to the boundary</span>
<span class="sd">          - Update the success history:</span>
<span class="sd">            - If crosswind: update the success history (increases if</span>
<span class="sd">              the fly collected evidence in that direction, decreases otherwise)</span>
<span class="sd">            - If close to boundary and the fly is not upwind: decrease success history</span>
<span class="sd">          - Update the descending drive</span>
<span class="sd">          - Increment time and counters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fly_orientation : np.array</span>
<span class="sd">            The fly orientation vector</span>
<span class="sd">        odor_intensities : np.array</span>
<span class="sd">            The odor intensities collected by the fly</span>
<span class="sd">        close_to_boundary : bool</span>
<span class="sd">            Whether the fly is close to the boundary</span>
<span class="sd">        curr_time : float</span>
<span class="sd">            The current time of the simulation</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dn_drive : np.array</span>
<span class="sd">            The dn drive that will make the fly go in the correct direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_refractory_period</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">boundary_inv</span> <span class="o">=</span> <span class="n">close_to_boundary</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">==</span> <span class="mf">0.0</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_threshold</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">since_last_decision_time</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">default_decision_interval</span>
            <span class="ow">or</span> <span class="n">boundary_inv</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_threshold</span><span class="p">:</span>
                <span class="c1"># reset the history and just take into account the last success</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">boundary_inv</span><span class="p">:</span>
                <span class="c1"># if close to the boundary and not upwind</span>
                <span class="c1"># decrease the success history of the correct directions as it led the</span>
                <span class="c1"># fly to the boundary</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="o">-</span><span class="mi">45</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># else update the success history if crosswind and</span>
                <span class="c1"># the fly collected evidence in that direction</span>
                <span class="c1"># increase the success history</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="o">-</span><span class="mi">45</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_evidence</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">45</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span>
                        <span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_evidence</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="p">)</span>

            <span class="c1"># reset counters</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">target_angle</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_target_angle</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">since_last_decision_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># update the accumulated evidence</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="n">odor_intensities</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_odor_gain</span>
                <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">accumulation_decay</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">curr_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive_update_steps</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="ow">or</span> <span class="n">boundary_inv</span>
        <span class="p">):</span>
            <span class="c1"># §update the dn drive</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curr_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">angle_to_dn_drive</span><span class="p">(</span><span class="n">fly_orientation</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">since_last_decision_time</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timestep</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset all the counters and parameters of the controller</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        seed : int</span>
<span class="sd">            The random seed to use for the controller</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accumulated_evidence</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">since_last_decision_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upwind_success</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">boundary_time</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_upwind_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curr_state</span> <span class="o">=</span> <span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dn_drive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dn_drives</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">curr_state</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_debug_str</span><span class="p">(</span>
    <span class="n">accumulated_evidence</span><span class="p">,</span> <span class="n">curr_angle</span><span class="p">,</span> <span class="n">target_angle</span><span class="p">,</span> <span class="n">crosswind_success_proba</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a string that represents the state of the controller</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">crosswind_success_proba_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">co</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">co</span> <span class="ow">in</span> <span class="n">crosswind_success_proba</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;Accumulated evidence: </span><span class="si">{</span><span class="n">accumulated_evidence</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;Fly orientation: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">curr_angle</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;Target angle: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">target_angle</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="sa">f</span><span class="s2">&quot;Crosswind success proba: </span><span class="si">{</span><span class="n">crosswind_success_proba_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_walking_icons</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get all icons representing the walking directions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">icons_dir</span> <span class="o">=</span> <span class="n">get_data_path</span><span class="p">(</span><span class="s2">&quot;flygym&quot;</span><span class="p">,</span> <span class="s2">&quot;data&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="s2">&quot;etc/locomotion_icons&quot;</span>
    <span class="n">icons</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;forward&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="s2">&quot;stop&quot;</span><span class="p">]:</span>
        <span class="n">icon_path</span> <span class="o">=</span> <span class="n">icons_dir</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">.png&quot;</span>
        <span class="n">icons</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">icon_path</span><span class="p">),</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_UNCHANGED</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">WalkingState</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">:</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;forward&quot;</span><span class="p">],</span>
        <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_LEFT</span><span class="p">:</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">],</span>
        <span class="n">WalkingState</span><span class="o">.</span><span class="n">TURN_RIGHT</span><span class="p">:</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">],</span>
        <span class="n">WalkingState</span><span class="o">.</span><span class="n">STOP</span><span class="p">:</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;stop&quot;</span><span class="p">],</span>
    <span class="p">}</span>


<span class="k">def</span><span class="w"> </span><span class="nf">get_inflow_circle</span><span class="p">(</span><span class="n">inflow_pos</span><span class="p">,</span> <span class="n">inflow_radius</span><span class="p">,</span> <span class="n">camera_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the xy locations of the inflow circle in the camera view</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># draw a circle around the inflow position (get x y pos of</span>
    <span class="c1"># a few points on the circle)</span>
    <span class="n">circle_x</span><span class="p">,</span> <span class="n">circle_y</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">angle</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="n">circle_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inflow_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">inflow_radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>
        <span class="n">circle_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inflow_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">inflow_radius</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span>

    <span class="n">xyz_global</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">circle_x</span><span class="p">,</span> <span class="n">circle_y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">circle_x</span><span class="p">)])</span>

    <span class="c1"># project those points on the camera view</span>
    <span class="c1"># Camera matrices multiply homogenous [x, y, z, 1] vectors.</span>
    <span class="n">corners_homogeneous</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="n">xyz_global</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">corners_homogeneous</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xyz_global</span>

    <span class="c1"># Project world coordinates into pixel space. See:</span>
    <span class="c1"># https://en.wikipedia.org/wiki/3D_projection#Mathematical_formula</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">camera_matrix</span> <span class="o">@</span> <span class="n">corners_homogeneous</span>

    <span class="c1"># x and y are in the pixel coordinate system.</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">xs</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">ys</span> <span class="o">/</span> <span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">render_overlay</span><span class="p">(</span>
    <span class="n">rendered_img</span><span class="p">,</span>
    <span class="n">accumulated_evidence</span><span class="p">,</span>
    <span class="n">fly_orientation</span><span class="p">,</span>
    <span class="n">target_angle</span><span class="p">,</span>
    <span class="n">crosswind_success_proba</span><span class="p">,</span>
    <span class="n">icon</span><span class="p">,</span>
    <span class="n">window_size</span><span class="p">,</span>
    <span class="n">inflow_x</span><span class="p">,</span>
    <span class="n">inflow_y</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to modify the simulation rendered images</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">rendered_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sub_strings</span> <span class="o">=</span> <span class="n">get_debug_str</span><span class="p">(</span>
            <span class="n">accumulated_evidence</span><span class="p">,</span>
            <span class="n">get_vector_angle</span><span class="p">(</span><span class="n">fly_orientation</span><span class="p">),</span>
            <span class="n">target_angle</span><span class="p">,</span>
            <span class="n">crosswind_success_proba</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># put string at the top left corner of the image</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">sub_string</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sub_strings</span><span class="p">):</span>
            <span class="n">rendered_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">putText</span><span class="p">(</span>
                <span class="n">rendered_img</span><span class="p">,</span>
                <span class="n">sub_string</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_strings</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">15</span><span class="p">),</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">FONT_HERSHEY_SIMPLEX</span><span class="p">,</span>
                <span class="mf">0.4</span><span class="p">,</span>
                <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="n">cv2</span><span class="o">.</span><span class="n">LINE_AA</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="c1"># put the icon just under the debug string</span>
        <span class="n">rendered_img</span><span class="p">[</span>
            <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">icon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">:</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">100</span><span class="p">,</span>
            <span class="mi">0</span> <span class="p">:</span> <span class="n">icon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">:,</span>
        <span class="p">]</span> <span class="o">=</span> <span class="n">icon</span>

        <span class="c1"># draw the inflow circle as a free line</span>
        <span class="n">rendered_img</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">polylines</span><span class="p">(</span>
            <span class="n">rendered_img</span><span class="p">,</span>
            <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">inflow_x</span><span class="p">,</span> <span class="n">inflow_y</span><span class="p">))])],</span>
            <span class="n">isClosed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">thickness</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">rendered_img</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_close_to_boundary</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">arena_size</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mf">5.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if the fly is close to the boundary</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">margin</span>
        <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">margin</span>
        <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">margin</span>
        <span class="ow">or</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">margin</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>Now, let’s run this controller:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">dm_control.mujoco</span><span class="w"> </span><span class="kn">import</span> <span class="n">Camera</span> <span class="k">as</span> <span class="n">DmCamera</span>

<span class="c1"># write the same loop as before but with the new controller</span>
<span class="n">timestep</span> <span class="o">=</span> <span class="mf">1e-4</span>
<span class="n">run_time</span> <span class="o">=</span> <span class="mf">10.0</span>

<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">arena</span> <span class="o">=</span> <span class="n">OdorPlumeArena</span><span class="p">(</span>
    <span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume_tcropped.hdf5&quot;</span><span class="p">,</span>
    <span class="n">plume_simulation_fps</span><span class="o">=</span><span class="mi">800</span><span class="p">,</span>
    <span class="n">dimension_scale_factor</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Define the fly</span>
<span class="n">contact_sensor_placements</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">leg</span><span class="si">}{</span><span class="n">segment</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LF&quot;</span><span class="p">,</span> <span class="s2">&quot;LM&quot;</span><span class="p">,</span> <span class="s2">&quot;LH&quot;</span><span class="p">,</span> <span class="s2">&quot;RF&quot;</span><span class="p">,</span> <span class="s2">&quot;RM&quot;</span><span class="p">,</span> <span class="s2">&quot;RH&quot;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Tibia&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus1&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus2&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus3&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus4&quot;</span><span class="p">,</span> <span class="s2">&quot;Tarsus5&quot;</span><span class="p">]</span>
<span class="p">]</span>

<span class="n">fly</span> <span class="o">=</span> <span class="n">Fly</span><span class="p">(</span>
    <span class="n">enable_adhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">draw_adhesion</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">enable_olfaction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">enable_vision</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">contact_sensor_placements</span><span class="o">=</span><span class="n">contact_sensor_placements</span><span class="p">,</span>
    <span class="c1"># Here the opposite spawn position can be tried (65.0, 15.0, 0.25)</span>
    <span class="n">spawn_pos</span><span class="o">=</span><span class="p">(</span><span class="mf">65.0</span><span class="p">,</span> <span class="mf">45.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">),</span>
    <span class="n">spawn_orientation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
<span class="p">)</span>

<span class="n">wind_dir</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
<span class="n">ctrl</span> <span class="o">=</span> <span class="n">SimplePlumeNavigationController</span><span class="p">(</span><span class="n">timestep</span><span class="p">,</span> <span class="n">wind_dir</span><span class="o">=</span><span class="n">wind_dir</span><span class="p">)</span>

<span class="n">cam_params</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;mode&quot;</span><span class="p">:</span><span class="s2">&quot;fixed&quot;</span><span class="p">,</span>
    <span class="s2">&quot;pos&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="mf">0.50</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="mf">0.15</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="mf">1.00</span> <span class="o">*</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">),</span>
    <span class="s2">&quot;euler&quot;</span><span class="p">:(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mi">15</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;fovy&quot;</span><span class="p">:</span><span class="mi">60</span><span class="p">}</span>

<span class="n">cam</span> <span class="o">=</span> <span class="n">Camera</span><span class="p">(</span>
    <span class="n">attachment_point</span><span class="o">=</span><span class="n">arena</span><span class="o">.</span><span class="n">root_element</span><span class="o">.</span><span class="n">worldbody</span><span class="p">,</span>
    <span class="n">camera_name</span><span class="o">=</span><span class="n">main_camera_name</span><span class="p">,</span>
    <span class="n">timestamp_text</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">camera_parameters</span><span class="o">=</span><span class="n">cam_params</span>
<span class="p">)</span>

<span class="n">dm_cam</span> <span class="o">=</span> <span class="n">DmCamera</span><span class="p">(</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">physics</span><span class="p">,</span>
    <span class="n">camera_id</span><span class="o">=</span><span class="n">cam</span><span class="o">.</span><span class="n">camera_id</span><span class="p">,</span>
    <span class="n">width</span><span class="o">=</span><span class="n">cam</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">height</span><span class="o">=</span><span class="n">cam</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
<span class="p">)</span>
<span class="n">camera_matrix</span> <span class="o">=</span> <span class="n">dm_cam</span><span class="o">.</span><span class="n">matrix</span>
<span class="n">arena_inflow_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inflow_pos</span><span class="p">)</span> <span class="o">/</span> <span class="n">arena</span><span class="o">.</span><span class="n">dimension_scale_factor</span> <span class="o">*</span> <span class="n">smoke_grid_size</span>
<span class="n">target_inflow_radius</span> <span class="o">=</span> <span class="mf">5.0</span>
<span class="n">inflow_x</span><span class="p">,</span> <span class="n">inflow_y</span> <span class="o">=</span> <span class="n">get_inflow_circle</span><span class="p">(</span>
    <span class="n">arena_inflow_pos</span><span class="p">,</span>
    <span class="n">target_inflow_radius</span><span class="p">,</span>
    <span class="n">camera_matrix</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">sim</span> <span class="o">=</span> <span class="n">PlumeNavigationTask</span><span class="p">(</span>
    <span class="n">fly</span><span class="o">=</span><span class="n">fly</span><span class="p">,</span>
    <span class="n">arena</span><span class="o">=</span><span class="n">arena</span><span class="p">,</span>
    <span class="n">cameras</span><span class="o">=</span><span class="p">[</span><span class="n">cam</span><span class="p">],</span>
<span class="p">)</span>

<span class="n">walking_icons</span> <span class="o">=</span> <span class="n">get_walking_icons</span><span class="p">()</span>

<span class="n">obs</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">trange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">run_time</span> <span class="o">/</span> <span class="n">timestep</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)):</span>
    <span class="n">fly_orientation</span> <span class="o">=</span> <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;fly_orientation&quot;</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">fly_orientation</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fly_orientation</span><span class="p">)</span>
    <span class="n">close_to_boundary</span> <span class="o">=</span> <span class="n">is_close_to_boundary</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;fly&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">],</span> <span class="n">arena</span><span class="o">.</span><span class="n">arena_size</span><span class="p">)</span>
    <span class="n">dn_drive</span> <span class="o">=</span> <span class="n">ctrl</span><span class="o">.</span><span class="n">step</span><span class="p">(</span>
        <span class="n">fly_orientation</span><span class="p">,</span> <span class="n">obs</span><span class="p">[</span><span class="s2">&quot;odor_intensity&quot;</span><span class="p">],</span> <span class="n">close_to_boundary</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">curr_time</span>
    <span class="p">)</span>

    <span class="n">obs</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">terminated</span><span class="p">,</span> <span class="n">truncated</span><span class="p">,</span> <span class="n">info</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">dn_drive</span><span class="p">)</span>

    <span class="n">icon</span> <span class="o">=</span> <span class="n">walking_icons</span><span class="p">[</span><span class="n">ctrl</span><span class="o">.</span><span class="n">curr_state</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">rendered_img</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">render</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">rendered_img</span> <span class="o">=</span> <span class="n">render_overlay</span><span class="p">(</span>
        <span class="n">rendered_img</span><span class="p">,</span>
        <span class="n">ctrl</span><span class="o">.</span><span class="n">accumulated_evidence</span><span class="p">,</span>
        <span class="n">fly_orientation</span><span class="p">,</span>
        <span class="n">ctrl</span><span class="o">.</span><span class="n">target_angle</span><span class="p">,</span>
        <span class="n">to_probability</span><span class="p">(</span><span class="n">ctrl</span><span class="o">.</span><span class="n">upwind_success</span><span class="p">),</span>
        <span class="n">icon</span><span class="p">,</span>
        <span class="n">cam</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
        <span class="n">inflow_x</span><span class="p">,</span>
        <span class="n">inflow_y</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">rendered_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cam</span><span class="o">.</span><span class="n">_frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">rendered_img</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">obs</span><span class="p">[</span><span class="s2">&quot;fly&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">arena_inflow_pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">target_inflow_radius</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The fly reached the inflow&quot;</span><span class="p">)</span>
        <span class="k">break</span>
    <span class="k">elif</span> <span class="n">truncated</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The fly went out of bound&quot;</span><span class="p">)</span>
        <span class="k">break</span>

    <span class="n">obs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obs</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>76%|███████▌  | 76026/100000 [04:04&lt;01:17, 310.69it/s]
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">The</span> <span class="n">fly</span> <span class="n">reached</span> <span class="n">the</span> <span class="n">inflow</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cam</span><span class="o">.</span><span class="n">save_video</span><span class="p">(</span><span class="n">output_dir</span> <span class="o">/</span> <span class="s2">&quot;plume_navigation_controller.mp4&quot;</span><span class="p">)</span>
</pre></div>
</div>
<video src="https://raw.githubusercontent.com/NeLy-EPFL/_media/main/flygym/plume_tracking/plume_navigation_controller.mp4" controls="controls" style="max-width: 400px;"></video></section>
</section>

        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="../api_ref/index.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">API Reference</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="advanced_vision.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Connectome-constrained visual system model</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; Neuroengineering Laboratory, EPFL
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://github.com/NeLy-EPFL/flygym" aria-label="GitHub">
                <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
                </svg>
            </a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Advanced olfaction: Navigating a complex odor plume</a><ul>
<li><a class="reference internal" href="#simulating-a-complex-odor-plume">Simulating a complex odor plume</a></li>
<li><a class="reference internal" href="#creating-a-plume-within-an-arena">Creating a plume within an arena</a></li>
<li><a class="reference internal" href="#plume-tracking-task">Plume tracking task</a></li>
<li><a class="reference internal" href="#implementing-a-plume-tracking-controller">Implementing a plume tracking controller</a></li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script src="../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/scripts/furo.js?v=46bd48cc"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>